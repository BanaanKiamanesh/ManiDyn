classdef ManipulatorKinematics
    properties (Access = private)
        DH
        DOF
    end

    methods
        function obj = ManipulatorKinematics(DH)
            arguments
                DH (1, 1) struct
            end

            % Check DH
            dhReq = {'alpha', 'a', 'd', 'theta', 'type'};
            if ~all(isfield(DH, dhReq))
                dhMissing = dhReq(~isfield(DH, dhReq));
                error('ManipulatorKinematics:BadDH', ...
                    'DH struct missing field(s): %s', ...
                    strjoin(dhMissing, ', '));
            end

            % Check DH Elements
            nLinks = numel(DH.alpha);
            if any([numel(DH.a), numel(DH.d), numel(DH.theta), ...
                    numel(DH.type)] ~= nLinks)
                error('ManipulatorKinematics:SizeMismatch', ...
                    'Each DH vector must have %d elements.', nLinks);
            end

            % Store, if Everything Looks Good
            obj.DH = orderfields(DH);
            obj.DOF = nLinks;
        end

        function [RotKine, TransKine] = CalculateFK(obj, varargin)

            % Parse Inputs
            Parser = inputParser;
            addParameter(Parser, 'Generate', "none", @(s)isstring(s) || ischar(s));
            addParameter(Parser, 'File', "forward_kinematics", @(s)isstring(s) || ischar(s));
            parse(Parser, varargin{:});

            gType = lower(string(Parser.Results.Generate));
            fBase = char(Parser.Results.File);

            % Calculate FK
            q = sym('q', [obj.DOF, 1], 'real');

            DHMod = obj.DH;
            DHMod.alpha = sym(DHMod.alpha);
            DHMod.d     = sym(DHMod.d);
            DHMod.theta = sym(DHMod.theta);
            DHMod.a     = sym(DHMod.a);

            for i = 1:obj.DOF
                if obj.DH.type == 'r'       % For Rev Joint
                    DHMod.theta(i) = DHMod.theta(i) + q(i);
                elseif obj.DH.type == 'p'   % For Prism Joint
                    DHMod.theta(i) = DHMod.d(i) + q(i);
                end
            end

            [R, P] = ParseDH(DHMod);

            RotKine = simplify(Rot2Eul(R{end}));
            TransKine = simplify(P{end});

            % Function Gen
            if gType == "mfile"
                matlabFunction([TransKine(:); RotKine(:)], 'File', fBase, ...
                    'Vars', {q}, 'Outputs', {'x'}, ...
                    'Comment', 'Forward kinematics: [P; Yaw Pitch Roll]');
                fprintf('MATLAB function "%s.m" generated.\n', fBase);

            elseif gType == "ccode"
                cstr = ccode([TransKine(:); RotKine(:)]);
                fid  = fopen([fBase '.c'], 'w');
                fprintf(fid,'/* Forward kinematics generated by CalculateFK */\n');
                fprintf(fid,'%s', cstr);
                fclose(fid);
                fprintf('C code "%s.c" generated.\n', fBase);
            end
        end
    end
end
