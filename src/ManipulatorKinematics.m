classdef ManipulatorKinematics
    properties (Access = private)
        DH
        DOF
    end

    methods
        function obj = ManipulatorKinematics(DH)
            arguments
                DH (1, 1) struct
            end

            % Check DH
            dhReq = {'alpha', 'a', 'd', 'theta', 'type'};
            if ~all(isfield(DH, dhReq))
                dhMissing = dhReq(~isfield(DH, dhReq));
                error('ManipulatorKinematics:BadDH', ...
                    'DH struct missing field(s): %s', ...
                    strjoin(dhMissing, ', '));
            end

            % Check DH Elements
            nLinks = numel(DH.alpha);
            if any([numel(DH.a), numel(DH.d), numel(DH.theta), ...
                    numel(DH.type)] ~= nLinks)
                error('ManipulatorKinematics:SizeMismatch', ...
                    'Each DH vector must have %d elements.', nLinks);
            end

            % Store, if Everything Looks Good
            obj.DH = orderfields(DH);
            obj.DOF = nLinks;
        end

        function [RotKine, TransKine] = CalculateFK(obj, varargin)

            % Parse Inputs
            Parser = inputParser;
            addParameter(Parser, 'Generate', "none"              , @(s)isstring(s) || ischar(s));
            addParameter(Parser, 'File'    , "forward_kinematics", @(s)isstring(s) || ischar(s));
            parse(Parser, varargin{:});

            gType = lower(string(Parser.Results.Generate));
            fBase = char(Parser.Results.File);

            % Calculate the Symbolic DH to Parse
            [DHMod, q] = obj.SymbolicDH;

            % Parse DH to Get Rotation Matrices and COM Positions at Each Frame
            [R, P] = ParseDH(DHMod);

            RotKine = simplify(Rot2Eul(R{end}));
            TransKine = simplify(P{end});

            % Function Gen
            if gType == "mfile"
                matlabFunction([TransKine(:); RotKine(:)], 'File', fBase, ...
                    'Vars', {q}, 'Outputs', {'x'}, ...
                    'Comment', 'Forward kinematics: [P; Yaw Pitch Roll]');
                fprintf('MATLAB function "%s.m" generated.\n', fBase);

            elseif gType == "ccode"
                cstr = ccode([TransKine(:); RotKine(:)]);
                fid  = fopen([fBase '.c'], 'w');
                fprintf(fid, '/* Forward kinematics generated by CalculateFK */\n');
                fprintf(fid, '%s', cstr);
                fclose(fid);
                fprintf('C code "%s.c" generated.\n', fBase);
            end
        end

        function J = Jacobian(obj, varargin)

            Parser = inputParser;
            addParameter(Parser, 'Type'    , "geometric", @(s)isstring(s)||ischar(s));
            addParameter(Parser, 'Generate',      "none", @(s)isstring(s)||ischar(s));
            addParameter(Parser, 'File'    ,  "jacobian", @(s)isstring(s)||ischar(s));
            parse(Parser, varargin{:});

            jType  = lower(string(Parser.Results.Type));
            gType  = lower(string(Parser.Results.Generate));
            fBase  = char(Parser.Results.File);

            % Calculate the Symbolic DH to Parse
            [DHMod, q] = obj.SymbolicDH;

            % Choose Formulation
            switch jType
                case "geometric"
                    % Parse DH to Get Rotation Matrices and COM Positions at Each Frame
                    [R, P] = ParseDH(DHMod);

                    Pe = P{end};                       % End-Effector Pos
                    Jp = sym(zeros(3, obj.DOF));
                    Jo = sym(zeros(3, obj.DOF));

                    zPrev = [0; 0; 1];   % z0
                    pPrev = [0; 0; 0];   % O0
                    for i = 1:obj.DOF
                        if i > 1
                            zPrev = R{i-1}(:, 3);
                            pPrev = P{i-1};
                        end
                        if DHMod.type(i) == 'r'              % Rev
                            Jo(:, i) = zPrev;
                            Jp(:, i) = cross(zPrev, Pe - pPrev);
                        else                                 % Prism
                            Jo(:, i) = sym([0; 0; 0]);
                            Jp(:, i) = zPrev;
                        end
                    end
                    J = simplify([Jp; Jo]);

                case "analytical"
                    % FK pose vector x = [Px; Py; Pz; Yaw; Pitch; Roll]
                    [R, P] = ParseDH(DHMod);
                    x  = [P{end}; Rot2Eul(R{end})];
                    J  = simplify(jacobian(x, q));

                otherwise
                    error('ManipulatorKinematics:BadType', ...
                        'Unknown Jacobian type "%s".', jType);
            end

            % Function Gen
            if gType == "mfile"
                matlabFunction(J, 'File', fBase, 'Vars', {q}, 'Outputs', {'J'}, ...
                    'Comment', ['Jacobian (' jType ')']);
                fprintf('MATLAB function "%s.m" generated.\n', fBase);

            elseif gType == "ccode"
                fid = fopen([fBase '.c'], 'w');
                fprintf(fid, '/* Jacobian (%s) generated by ManipulatorKinematics */\n', jType);
                fprintf(fid, '%s', ccode(J));
                fclose(fid);
                fprintf('C code "%s.c" generated.\n', fBase);
            end
        end
    end

    methods (Access = private)
        function [DHMod, q] = SymbolicDH(obj)
            % Calculate FK
            q = sym('q', [obj.DOF, 1], 'real');

            DHMod = obj.DH;
            DHMod.alpha = sym(DHMod.alpha);
            DHMod.d     = sym(DHMod.d);
            DHMod.theta = sym(DHMod.theta);
            DHMod.a     = sym(DHMod.a);

            for i = 1:obj.DOF
                if obj.DH.type(i) == 'r'       % For Rev Joint
                    DHMod.theta(i) = DHMod.theta(i) + q(i);
                elseif obj.DH.type == 'p'      % For Prism Joint
                    DHMod.theta(i) = DHMod.d(i) + q(i);
                end
            end
        end
    end
end
